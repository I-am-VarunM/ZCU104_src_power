`timescale 1ns / 1ps
`include "parameters.v"

module gpio_port(
	clk, 
	reset, 
	gpio_pins, 
	INT, 
	spi_write_int, 
	ready, 
	read, 
	address, 
	value_register_input, 
	value_register_output, 
	value_wen,
	fifo_write,
	fifo_wen);

input clk;
input reset;

/* the pins coming in */
inout [`GPIO_PINS-1:0]gpio_pins;
/* the gpio_ports in out wires.  This is needed to properly deal with the
* two way nature of the ports */
wire [`GPIO_PINS-1:0]gpio_pins_out;
wire [`GPIO_PINS-1:0]gpio_pins_in;

/* for the chip interrupt on reads or keypresses */
output INT;
wire INT;

/* spi_write_int is a signal which tells if a write happens and we need to
* reinitialize the directions and values of the gpio_pins */
input spi_write_int;
/* tells the control that it can initialize the gpio ports */
input ready;

/* the access pins to the register file */
input [`REG_WIDTH-1:0] read;
output [`ADDRESS_WIDTH-1:0] address;
reg [`ADDRESS_WIDTH-1:0] address;

/* access to the register files value register.  We get direct access since
* it is heavily used */
input [`REG_WIDTH-1:0]value_register_input;
output [`REG_WIDTH-1:0]value_register_output;
wire [`REG_WIDTH-1:0]value_register_output;
output value_wen;
wire value_wen;

/* init direction is the initial state to send out all Zs on the gpios */
reg init_direction;

reg [`GPIO_PINS-1:0]control_register;
/* the register indicating which reading pins interrupt */
reg [`GPIO_PINS-1:0]interrupt_register;
/* the register containing the direction of each gpio_pin.
* 1 = input/reads, 0 = output/writes */
reg [`GPIO_PINS-1:0]direction_register;
/* the values for the right and read registers */
reg [`GPIO_PINS-1:0]value_register;
/* the register for directions of pins in keypad mode */
wire [`GPIO_PINS-1:0]mask_keypad_dir_register;
/* the pins in the keypad that are dedicate for each row and collumn */
wire [`GPIO_PINS-1:0]mask_column_bits; // collumns send out signals
wire [`GPIO_PINS-1:0]mask_row_bits; // rows are read

/* control signals to the two different units of gpio behaviour */
reg gpio_ctrl_ready;
reg keypad_ready;
// this is the interrupt signal generated by the non-keypad pins...
wire gpio_ctrl_interrupt; 
wire keypad_interrupt; 

/* control of when to write keypresses to the fifo */
output fifo_wen;
wire fifo_wen;
output [`REG_WIDTH-1:0]fifo_write;
wire [`REG_WIDTH-1:0]fifo_write;

/* the output from the keypad controller */
wire [`GPIO_PINS-1:0]keypad_controller_out;

parameter STATE_SIZE=7;
parameter RESET =							7'b0000001, // 01
			INIT =	 					7'b0000010, // 02
			SET_CONTROL_REGISTER =				7'b0000100, // 04
			SET_INT_REGISTER = 				7'b0001000, // 08
			SET_DIRECTION_REGISTER_AND_VALUE_REGISTER = 	7'b0010000, // 10
			NORMAL_OPERATION = 				7'b1000000; // 12
			
reg [STATE_SIZE-1:0]state;
reg [STATE_SIZE-1:0]next_state;

// module for the keypad controller
keypad_controller kc(
	.clk(clk), 
	.reset(reset), 
	.gpio_pins_in(gpio_pins_in), 
	.keypad_controller_out(keypad_controller_out), 
	.row_mask(mask_row_bits), 
	.column_mask(mask_column_bits), 
	.control_register(control_register), 
	.ready(keypad_ready), 
	.interrupt(keypad_interrupt), 
	.fifo_out(fifo_write),
	.fifo_wen(fifo_wen));

// the controller for the pins in non-keypad mode
gpio_read_pins read_controller(
	.clk(clk), 
	.reset(reset), 
	.gpio_pins_in(gpio_pins_in), 
	.read_mask(direction_register), 
	.interrupt_mask(interrupt_register), 
	.ready(gpio_ctrl_ready), 
	.interrupt(gpio_ctrl_interrupt), 
	.value_register_input(value_register_input), 
	.value_register_output(value_register_output), 
	.value_wen(value_wen));

// figure out the pins that are dedicated for keypad
turn_on_ports pins_used_by_keypad1(control_register[3:0]+{2'b00,control_register[6:4]}, mask_keypad_dir_register);
// figure out the keypad row pins
turn_on_ports pins_used_by_keypad2({1'b0, control_register[3:0]}, mask_row_bits);
// figure out the keypad collumn pins
assign mask_column_bits = mask_keypad_dir_register & ~mask_row_bits;

// simple interrupt behaviour since we just or them
assign INT = gpio_ctrl_interrupt | keypad_interrupt;

// always write out on these pins.  The direction register masks out non writing bis
assign gpio_pins_out = (value_register & ~mask_keypad_dir_register) | (keypad_controller_out & mask_keypad_dir_register);

// mask for the output pins
assign gpio_pins[0] = (init_direction && !direction_register [0]) ? gpio_pins_out[0] : 1'bz;
assign gpio_pins[1] = (init_direction && !direction_register [1]) ? gpio_pins_out[1] : 1'bz;
assign gpio_pins[2] = (init_direction && !direction_register [2]) ? gpio_pins_out[2] : 1'bz;
assign gpio_pins[3] = (init_direction && !direction_register [3]) ? gpio_pins_out[3] : 1'bz;
assign gpio_pins[4] = (init_direction && !direction_register [4]) ? gpio_pins_out[4] : 1'bz;
assign gpio_pins[5] = (init_direction && !direction_register [5]) ? gpio_pins_out[5] : 1'bz;
assign gpio_pins[6] = (init_direction && !direction_register [6]) ? gpio_pins_out[6] : 1'bz;
assign gpio_pins[7] = (init_direction && !direction_register [7]) ? gpio_pins_out[7] : 1'bz;
assign gpio_pins[8] = (init_direction && !direction_register [8]) ? gpio_pins_out[8] : 1'bz;
assign gpio_pins[9] = (init_direction && !direction_register [9]) ? gpio_pins_out[9] : 1'bz;
assign gpio_pins[10] = (init_direction && !direction_register [10]) ? gpio_pins_out[10] : 1'bz;
assign gpio_pins[11] = (init_direction && !direction_register [11]) ? gpio_pins_out[11] : 1'bz;
assign gpio_pins[12] = (init_direction && !direction_register [12]) ? gpio_pins_out[12] : 1'bz;
assign gpio_pins[13] = (init_direction && !direction_register [13]) ? gpio_pins_out[13] : 1'bz;
assign gpio_pins[14] = (init_direction && !direction_register [14]) ? gpio_pins_out[14] : 1'bz;
assign gpio_pins[15] = (init_direction && !direction_register [15]) ? gpio_pins_out[15] : 1'bz;

// mask for the input pins
assign gpio_pins_in[0] = (init_direction && direction_register [0]) ? gpio_pins[0] : 1'bz;
assign gpio_pins_in[1] = (init_direction && direction_register [1]) ? gpio_pins[1] : 1'bz;
assign gpio_pins_in[2] = (init_direction && direction_register [2]) ? gpio_pins[2] : 1'bz;
assign gpio_pins_in[3] = (init_direction && direction_register [3]) ? gpio_pins[3] : 1'bz;
assign gpio_pins_in[4] = (init_direction && direction_register [4]) ? gpio_pins[4] : 1'bz;
assign gpio_pins_in[5] = (init_direction && direction_register [5]) ? gpio_pins[5] : 1'bz;
assign gpio_pins_in[6] = (init_direction && direction_register [6]) ? gpio_pins[6] : 1'bz;
assign gpio_pins_in[7] = (init_direction && direction_register [7]) ? gpio_pins[7] : 1'bz;
assign gpio_pins_in[8] = (init_direction && direction_register [8]) ? gpio_pins[8] : 1'bz;
assign gpio_pins_in[9] = (init_direction && direction_register [9]) ? gpio_pins[9] : 1'bz;
assign gpio_pins_in[10] = (init_direction && direction_register [10]) ? gpio_pins[10] : 1'bz;
assign gpio_pins_in[11] = (init_direction && direction_register [11]) ? gpio_pins[11] : 1'bz;
assign gpio_pins_in[12] = (init_direction && direction_register [12]) ? gpio_pins[12] : 1'bz;
assign gpio_pins_in[13] = (init_direction && direction_register [13]) ? gpio_pins[13] : 1'bz;
assign gpio_pins_in[14] = (init_direction && direction_register [14]) ? gpio_pins[14] : 1'bz;
assign gpio_pins_in[15] = (init_direction && direction_register [15]) ? gpio_pins[15] : 1'bz;

always @(posedge clk or posedge reset)
begin
	if (reset == 1'b1)
	begin
		init_direction <= 1'b0; // makesure nothing is written out or accepted until the first initlization sequence is done
		direction_register <= 0;
		interrupt_register <= 0;
		value_register <= 0;
		control_register <= 0;
		gpio_ctrl_ready <= 1'b0; // this controls the reading interrupt and writing control
		address <= 0;
		keypad_ready <= 1'b0; // this controls the keypad reader
	end
	else
	begin
		case (state)
			INIT:
			begin
				/* read control register */
				address <= 0;
			end
			SET_CONTROL_REGISTER:
			begin
				/* read interrupt register */
				address <= 1;
				control_register <= read;
			end
			SET_INT_REGISTER:
			begin
				/* read direction register */
				address <= 2;
				interrupt_register <= read;
			end
			SET_DIRECTION_REGISTER_AND_VALUE_REGISTER:
			begin
				direction_register <= ((read & ~mask_keypad_dir_register) | mask_row_bits); // first part picks reads not in use by keypda.  Last or picks the row bits which will be reads
				/* read value register - can read right away since we get port directly */
				value_register <= (value_register_input & ~direction_register); // only put in write bits
			end
			NORMAL_OPERATION:
			begin
				init_direction <= 1'b1;
				gpio_ctrl_ready <= 1'b1;
				keypad_ready <= 1'b1;
			end
			default: 
			begin
			end
		endcase

	end
end

/* Combinational state machine */
always @(state or ready or spi_write_int)
begin
	next_state = 0;
	case (state)
		RESET:
		begin
			if (ready == 1'b1)
			begin
				next_state = INIT;
			end
			else
			begin
				next_state = RESET;
			end
		end
		INIT:
		begin
			next_state = SET_CONTROL_REGISTER;
		end
		SET_CONTROL_REGISTER:
		begin
			if (spi_write_int == 1'b1)
			begin
				next_state = INIT;
			end
			else
			begin
				next_state = SET_INT_REGISTER;
			end
		end
		SET_INT_REGISTER:
		begin
			if (spi_write_int == 1'b1)
			begin
				next_state = INIT;
			end
			else
			begin
				next_state = SET_DIRECTION_REGISTER_AND_VALUE_REGISTER;
			end
		end
		SET_DIRECTION_REGISTER_AND_VALUE_REGISTER:
		begin
			if (spi_write_int == 1'b1)
			begin
				next_state = INIT;
			end
			else
			begin
				next_state = NORMAL_OPERATION;
			end
		end
		NORMAL_OPERATION:
		begin
			if (spi_write_int == 1'b1)
			begin
				next_state = INIT;
			end
			else
			begin
				next_state = NORMAL_OPERATION;
			end
		end
		default: 
		begin
			next_state = INIT;
		end
	endcase
end

/* sequential state changes */
always @(posedge clk or posedge reset)
begin
	if (reset == 1'b1)
	begin
		state <= RESET;
		next_state <= RESET;
	end
	else
	begin
		state <= next_state;
	end
end

endmodule
